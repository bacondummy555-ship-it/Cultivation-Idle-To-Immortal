<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path to Immortality</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --realm-color: #4c1d95;
            --glow: rgba(139, 92, 246, 0.5);
            --transition-smooth: cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        body {
            background-color: #050507;
            color: #e2e8f0;
            font-family: 'Georgia', serif;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }
        
        .qi-gradient {
            background: linear-gradient(90deg, var(--realm-color), #fff);
            box-shadow: 0 0 20px var(--realm-color);
            transition: width 0.3s var(--transition-smooth);
        }
        
        .mystic-border {
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background: rgba(15, 15, 20, 0.8);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .mystic-border:hover {
            border-color: var(--realm-color);
        }
        
        .auth-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0.75rem;
            border-radius: 0.5rem;
            width: 100%;
            outline: none;
            transition: 0.3s;
            color: white;
        }
        
        .auth-input:focus {
            border-color: #a855f7;
            box-shadow: 0 0 10px rgba(168, 85, 247, 0.3);
        }
        
        .btn-primary {
            background: #6d28d9;
            color: white;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.3s;
            width: 100%;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: #7c3aed;
            transform: translateY(-1px);
        }
        
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        @keyframes pulse-slow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .animate-pulse-slow {
            animation: pulse-slow 3s infinite;
        }
        
        .map-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
        }
        
        .tile {
            aspect-ratio: 1;
            border: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
            border-radius: 4px;
        }
        
        .tile-active {
            border: 1px solid #a855f7;
            box-shadow: inset 0 0 10px #a855f7;
        }
        
        .fog {
            background: #0a0a0a !important;
            color: #1a1a1a !important;
        }
        
        .tile-occupied {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(139, 92, 246, 0.05));
        }
        
        ::-webkit-scrollbar {
            width: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--realm-color);
            border-radius: 10px;
        }
        
        /* Prevent text selection for UI elements */
        .no-select {
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* Loading animation */
        @keyframes shimmer {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }
        
        .shimmer {
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.1) 50%,
                transparent 100%
            );
            background-size: 200% auto;
            animation: shimmer 2s infinite;
        }
        
        /* Performance optimizations */
        .will-change-transform {
            will-change: transform;
        }
        
        .will-change-opacity {
            will-change: opacity;
        }
    </style>
</head>
<body class="p-4 transition-colors duration-1000 no-select">
    <!-- Loading Screen -->
    <div id="loading-screen" class="fixed inset-0 bg-black z-[100] flex flex-col items-center justify-center">
        <div class="text-4xl font-black tracking-[0.3em] text-white mb-8 animate-pulse-slow">PATH TO IMMORTALITY</div>
        <div class="w-64 h-1 bg-gray-900 rounded-full overflow-hidden">
            <div id="loading-bar" class="h-full bg-purple-600 w-0 transition-all duration-500"></div>
        </div>
        <p class="mt-4 text-xs text-purple-500 font-mono tracking-widest uppercase">Touching the Heavens...</p>
    </div>

    <!-- Authentication Container -->
    <div id="auth-container" class="fixed inset-0 bg-black/90 z-[90] hidden items-center justify-center p-6">
        <div class="mystic-border p-8 rounded-3xl w-full max-w-md">
            <div id="login-form">
                <h2 class="text-2xl font-bold mb-6 text-center text-purple-400 font-serif">Divine Login</h2>
                <div class="space-y-4">
                    <input type="email" placeholder="Email" class="auth-input" id="login-email" autocomplete="email">
                    <input type="password" placeholder="Password" class="auth-input" id="login-pass" autocomplete="current-password">
                    <button id="login-btn" class="btn-primary">ENTER THE DAO</button>
                    <div class="flex justify-between text-xs text-gray-500 px-1">
                        <button data-action="register" class="hover:text-purple-400 transition-colors">Create Account</button>
                        <button data-action="forgot" class="hover:text-purple-400 transition-colors">Forgot</button>
                    </div>
                </div>
            </div>
            
            <div id="register-form" class="hidden">
                <h2 class="text-2xl font-bold mb-6 text-center text-green-400 font-serif">New Incarnation</h2>
                <div class="space-y-4">
                    <input type="text" placeholder="Daoist Name" class="auth-input" id="reg-name" autocomplete="name">
                    <input type="email" placeholder="Email" class="auth-input" id="reg-email" autocomplete="email">
                    <input type="password" placeholder="Password" class="auth-input" id="reg-pass" autocomplete="new-password">
                    <button id="reg-btn" class="btn-primary bg-green-700 hover:bg-green-600">REGISTER SOUL</button>
                    <button data-action="login" class="w-full text-xs text-gray-500 mt-2 hover:text-purple-400 transition-colors">Return to Void</button>
                </div>
            </div>
            
            <div id="forgot-form" class="hidden">
                <h2 class="text-2xl font-bold mb-6 text-center text-yellow-500 font-serif">Restore Tether</h2>
                <div class="space-y-4">
                    <p class="text-xs text-gray-400 mb-4">A spiritual link will be sent to your email.</p>
                    <input type="email" placeholder="Email" class="auth-input" id="forgot-email" autocomplete="email">
                    <button id="forgot-btn" class="btn-primary bg-yellow-700 hover:bg-yellow-600">SEND LINK</button>
                    <button data-action="login" class="w-full text-xs text-gray-500 mt-2 hover:text-purple-400 transition-colors">Back</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Game UI -->
    <div id="game-ui" class="opacity-0 transition-opacity duration-1000 will-change-opacity">
        <!-- Technique Selection -->
        <div id="technique-screen" class="fixed inset-0 bg-black/95 z-[60] hidden flex-col items-center justify-center p-6 text-center backdrop-blur-md">
            <h2 class="text-4xl font-bold text-purple-500 mb-8 tracking-tighter">Choose Your Technique</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 max-w-5xl">
                <div class="mystic-border p-6 rounded-2xl hover:border-blue-500 transition cursor-pointer" data-technique="turtle">
                    <h3 class="text-blue-400 font-bold text-xl mb-2">Steady Turtle</h3>
                    <div class="text-green-400 text-sm font-bold">+50% Success Rate</div>
                    <p class="text-xs text-gray-400 mt-2">Slow but reliable cultivation</p>
                </div>
                <div class="mystic-border p-6 rounded-2xl hover:border-yellow-500 transition cursor-pointer" data-technique="dao">
                    <h3 class="text-yellow-500 font-bold text-xl mb-2">Balanced Dao</h3>
                    <div class="text-blue-400 text-sm">Pure Path</div>
                    <p class="text-xs text-gray-400 mt-2">The middle way of cultivation</p>
                </div>
                <div class="mystic-border p-6 rounded-2xl hover:border-red-600 transition cursor-pointer" data-technique="phoenix">
                    <h3 class="text-red-500 font-bold text-xl mb-2">Raging Phoenix</h3>
                    <div class="text-green-400 text-sm font-bold">+100% Qi Speed</div>
                    <p class="text-xs text-gray-400 mt-2">Fast but risky advancement</p>
                </div>
            </div>
        </div>

        <!-- Reincarnation Screen -->
        <div id="reincarnation-screen" class="fixed inset-0 bg-black z-50 hidden flex-col items-center justify-center p-6 text-center">
            <h2 class="text-6xl font-bold text-yellow-500 mb-4">Life Exhausted</h2>
            <p id="death-msg" class="text-xl text-gray-400 mb-8"></p>
            <div class="text-2xl mb-8">Karma Earned: <span id="karma-gain" class="text-green-400 font-bold">0</span></div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 max-w-2xl">
                <button class="p-4 border border-gray-700 hover:border-purple-500 rounded-xl transition-colors" data-reincarnate="1" data-cost="0">Mortal Root (1x)</button>
                <button class="p-4 border border-gray-700 hover:border-purple-500 rounded-xl transition-colors" data-reincarnate="10" data-cost="1000">Heavenly Root (10x)</button>
            </div>
        </div>

        <!-- Main Game Interface -->
        <div class="max-w-7xl mx-auto">
            <header class="flex flex-col md:flex-row justify-between items-center mb-8 gap-4">
                <div>
                    <h1 class="text-4xl font-black uppercase tracking-widest text-white">Daoist <span id="p-name" class="text-purple-500">...</span></h1>
                    <p id="p-realm" class="text-yellow-500 font-bold text-xl uppercase tracking-wider">Mortal</p>
                    <button id="sign-out-btn" class="text-[10px] text-red-500 hover:underline transition-colors">Abandon Mortal Shell (Sign Out)</button>
                </div>
                <div class="flex gap-8 text-center bg-gray-900/50 p-4 rounded-2xl border border-white/5">
                    <div>
                        <p class="text-[10px] text-gray-500 uppercase">Lifespan</p>
                        <p class="font-mono text-lg"><span id="age">18</span>/<span id="maxAge">100</span></p>
                    </div>
                    <div>
                        <p class="text-[10px] text-gray-500 uppercase">Karma</p>
                        <p id="karma" class="font-mono text-lg text-green-400">0</p>
                    </div>
                </div>
            </header>

            <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
                <!-- Left Panel -->
                <div class="space-y-6">
                    <div class="mystic-border p-6 rounded-2xl">
                        <h2 class="text-sm font-bold uppercase text-gray-500 mb-4 flex justify-between">
                            Qi Reservoir <span id="success-val" class="text-green-500">100%</span>
                        </h2>
                        <div class="text-4xl font-mono font-bold mb-2 tracking-tighter" id="qi-val">0</div>
                        <div class="w-full bg-black/50 h-3 rounded-full overflow-hidden border border-white/5">
                            <div id="qi-bar" class="qi-gradient h-full"></div>
                        </div>
                        <div class="flex justify-between text-[10px] mt-2 text-gray-500 font-bold">
                            <span>Rate: <b id="rate-val" class="text-gray-300">0</b>/s</span>
                        </div>
                    </div>
                    
                    <div class="mystic-border p-4 rounded-2xl">
                        <h2 class="text-[10px] font-bold uppercase text-purple-400 mb-2">World Map</h2>
                        <div id="map-container" class="map-grid"></div>
                    </div>
                </div>

                <!-- Center Panel -->
                <div class="lg:col-span-2 space-y-6">
                    <div class="mystic-border h-80 rounded-3xl flex flex-col items-center justify-center relative overflow-hidden bg-gradient-to-b from-transparent to-purple-950/20">
                        <button id="meditate-btn" class="w-40 h-40 rounded-full border-4 border-purple-500/30 flex items-center justify-center bg-black/40 hover:scale-105 transition-all shadow-[0_0_50px_var(--realm-color)] will-change-transform group">
                            <span class="font-black text-xl group-hover:text-purple-400 transition-colors">MEDITATE</span>
                        </button>
                        <button id="break-btn" class="hidden absolute bottom-6 w-3/4 bg-yellow-500 text-black font-black py-4 rounded-lg animate-pulse z-20">FACING TRIBULATION</button>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="mystic-border p-4 rounded-2xl bg-black/20 h-64 overflow-hidden flex flex-col">
                            <h3 class="text-[10px] font-bold text-gray-600 uppercase mb-2">Daoist Records</h3>
                            <div id="log" class="flex-grow overflow-y-auto text-[11px] space-y-2 font-mono text-gray-400"></div>
                        </div>
                        
                        <div class="mystic-border p-4 rounded-2xl flex flex-col h-64">
                            <h2 class="text-[10px] font-bold uppercase text-gray-600 mb-2">World Transmission</h2>
                            <div id="chat" class="flex-grow overflow-y-auto space-y-2 mb-2 text-xs"></div>
                            <form id="chat-form" class="flex gap-2 pt-2 border-t border-white/5">
                                <input id="chat-input" type="text" placeholder="Speak..." class="bg-black/50 border border-white/10 rounded-lg p-2 flex-grow text-xs" maxlength="200">
                                <button type="submit" class="bg-purple-600 px-4 rounded-lg font-bold text-[10px] hover:bg-purple-700 transition-colors">SEND</button>
                            </form>
                        </div>
                    </div>
                </div>

                <!-- Right Panel - Leaderboard -->
                <div class="mystic-border p-6 rounded-2xl flex flex-col h-full max-h-[700px]">
                    <h2 class="text-sm font-bold uppercase text-purple-400 mb-4 border-b border-purple-900/50 pb-2 text-center">Heavenly Rankings</h2>
                    <ul id="leaderboard-list" class="space-y-3 overflow-y-auto pr-2"></ul>
                </div>
            </div>
        </div>

        <!-- Admin Panel -->
        <div id="admin-panel" class="hidden fixed bottom-4 left-4 z-[100] bg-red-950/90 border border-red-500 rounded-xl w-64 shadow-2xl">
            <div id="admin-header" class="p-3 border-b border-red-800 bg-red-900/50 rounded-t-xl cursor-grab active:cursor-grabbing">
                <h3 class="text-red-500 font-bold text-xs uppercase tracking-tighter">Heavenly Overseer Console</h3>
            </div>
            <div class="p-4 space-y-2">
                <button id="admin-reset-map" class="w-full bg-red-600 hover:bg-red-700 text-white text-[10px] font-bold py-2 rounded transition-colors">WIPE WORLD MAP</button>
                <button id="admin-add-karma" class="w-full bg-blue-600 hover:bg-blue-700 text-white text-[10px] font-bold py-2 rounded transition-colors">GIVE SELF 10,000 KARMA</button>
                <p class="text-[9px] text-red-300 mt-2">Active Administrator Detected</p>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, sendPasswordResetEmail, updateProfile } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, doc, setDoc, query, orderBy, limit, onSnapshot, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyD7N-ZUGKm9hasgM0DD08scouydEEuiLvU",
            authDomain: "path-to-immortality-78ad8.firebaseapp.com",
            projectId: "path-to-immortality-78ad8",
            storageBucket: "path-to-immortality-78ad8.firebasestorage.app",
            messagingSenderId: "653760996266",
            appId: "1:653760996266:web:59c8dc7158cba0722e01d3"
        };

        class Game {
            constructor() {
                this.app = initializeApp(firebaseConfig);
                this.auth = getAuth(this.app);
                this.db = getFirestore(this.app);
                this.SAVE_KEY_PREFIX = "ImmortalV7_User_";
                this.ADMIN_UID = "AGR9whqSLbQPefvXPUC4AMX5Fld2";
                
                this.currentUser = null;
                this.state = this.getDefaultState();
                this.mapData = this.initializeMapData();
                this.realms = this.initializeRealms();
                
                this.gameLoop = null;
                this.saveInterval = null;
                this.lastRenderTime = 0;
                this.renderFrameId = null;
                
                this.bindEvents();
            }
            
            getDefaultState() {
                return {
                    name: "",
                    qi: 0,
                    realmIdx: 0,
                    age: 18,
                    maxAge: 100,
                    upgrades: { spirit: 0, tech: 0 },
                    karma: 0,
                    rootMult: 1,
                    lastTick: Date.now(),
                    technique: "dao",
                    pos: -1,
                    techniqueChosen: false,
                    isDead: false,
                    moveCooldown: 0,
                    version: "1.0.0"
                };
            }
            
            initializeMapData() {
                return Array(25).fill(null).map((_, i) => ({
                    id: i,
                    lord: null,
                    level: 0,
                    density: 1 + (i % 5 * 0.5),
                    lordQi: 0,
                    lastUpdated: null
                }));
            }
            
            initializeRealms() {
                const realmNames = [
                    "Mortal Body", "Refined Body", "Tempered Flesh", "Bone Forging", "Blood Circulation", "Muscle Cleansing", "Meridian Awakening", "Qi Sense", "Qi Initiation", "Qi Condensation", "Qi Gathering", "Qi Foundation", "Qi Stabilization",
                    "Foundation Establishment", "Foundation Perfection", "Spirit Root Awakening", "Spirit Root Tempering", "Spirit Root Harmonization", "Golden Core (Early)", "Golden Core (Middle)", "Golden Core (Late)", "Golden Core (Perfected)",
                    "False Nascent Soul", "Nascent Soul (Early)", "Nascent Soul (Middle)", "Nascent Soul (Late)", "Nascent Soul (Perfected)", "Soul Infant", "Soul Transformation", "Soul Ascension", "Soul Integration",
                    "Spirit Severing", "Spirit Fusion", "Void Perception", "Void Refinement", "Dao Seed Formation", "Dao Comprehension", "Dao Integration", "Dao Manifestation", "Dao King",
                    "Earth Immortal", "Sky Immortal", "True Immortal", "Golden Immortal", "Heavenly Immortal", "Immortal Lord", "Immortal King", "Immortal Emperor",
                    "Pseudo-God", "Minor Deity", "True Deity", "High Deity", "Divine Lord", "Divine King", "Divine Emperor",
                    "Primordial Body", "Primordial Soul", "Primordial Dao", "Origin Being", "Origin Sovereign", "Origin Emperor",
                    "Void Ancestor", "Chaos Walker", "Chaos Sovereign", "Chaos Emperor", "Existence Transcendent", "Law Devourer", "Reality Shaper", "World Creator", "Multiverse Sovereign", "Omni-Existence", "Beyond Heaven", "Boundless One", "Absolute Apex"
                ];
                
                return realmNames.map((name, i) => ({
                    name,
                    req: Math.floor(100 * Math.pow(1.68, i)),
                    color: `hsl(${250 + (i * 3)}, 70%, 50%)`,
                    chance: Math.max(0.05, 1 - (i * 0.015))
                }));
            }
            
            bindEvents() {
                // Auth buttons
                document.getElementById('login-btn')?.addEventListener('click', () => this.handleLogin());
                document.getElementById('reg-btn')?.addEventListener('click', () => this.handleRegister());
                document.getElementById('forgot-btn')?.addEventListener('click', () => this.handleForgot());
                document.getElementById('sign-out-btn')?.addEventListener('click', () => this.signOut());
                
                // Auth switching
                document.querySelectorAll('[data-action]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.switchAuth(e.target.dataset.action);
                    });
                });
                
                // Technique selection
                document.querySelectorAll('[data-technique]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.setTechnique(e.currentTarget.dataset.technique);
                    });
                });
                
                // Reincarnation buttons
                document.querySelectorAll('[data-reincarnate]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const mult = parseInt(e.currentTarget.dataset.reincarnate);
                        const cost = parseInt(e.currentTarget.dataset.cost);
                        this.reincarnate(mult, cost);
                    });
                });
                
                // Game actions
                document.getElementById('meditate-btn')?.addEventListener('click', () => this.manualMeditate());
                document.getElementById('break-btn')?.addEventListener('click', () => this.breakthrough());
                
                // Admin actions
                document.getElementById('admin-reset-map')?.addEventListener('click', () => this.adminResetMap());
                document.getElementById('admin-add-karma')?.addEventListener('click', () => this.adminAddKarma());
                
                // Chat form
                document.getElementById('chat-form')?.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.sendChatMessage();
                });
                
                // Enter key for chat
                document.getElementById('chat-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendChatMessage();
                    }
                });
                
                // Add touch support for mobile
                this.addTouchSupport();
            }
            
            addTouchSupport() {
                // Prevent zoom on double tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
            }
            
            async init() {
                let prog = 0;
                const interval = setInterval(() => {
                    prog += 10;
                    const loadingBar = document.getElementById('loading-bar');
                    if (loadingBar) {
                        loadingBar.style.width = prog + "%";
                    }
                    if (prog >= 100) {
                        clearInterval(interval);
                        this.checkSession();
                        this.makeDraggable(document.getElementById("admin-panel"), document.getElementById("admin-header"));
                    }
                }, 100);
            }
            
            makeDraggable(el, handle) {
                if (!el || !handle) return;
                
                let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
                
                const dragMouseDown = (e) => {
                    e = e || window.event;
                    e.preventDefault();
                    
                    pos3 = e.clientX || e.touches?.[0]?.clientX || 0;
                    pos4 = e.clientY || e.touches?.[0]?.clientY || 0;
                    
                    document.addEventListener('mouseup', closeDragElement);
                    document.addEventListener('touchend', closeDragElement);
                    document.addEventListener('mousemove', elementDrag);
                    document.addEventListener('touchmove', elementDrag, { passive: false });
                };
                
                const elementDrag = (e) => {
                    e = e || window.event;
                    e.preventDefault();
                    
                    const clientX = e.clientX || e.touches?.[0]?.clientX || 0;
                    const clientY = e.clientY || e.touches?.[0]?.clientY || 0;
                    
                    pos1 = pos3 - clientX;
                    pos2 = pos4 - clientY;
                    pos3 = clientX;
                    pos4 = clientY;
                    
                    el.style.top = (el.offsetTop - pos2) + "px";
                    el.style.left = (el.offsetLeft - pos1) + "px";
                    el.style.bottom = "auto";
                };
                
                const closeDragElement = () => {
                    document.removeEventListener('mouseup', closeDragElement);
                    document.removeEventListener('mousemove', elementDrag);
                    document.removeEventListener('touchend', closeDragElement);
                    document.removeEventListener('touchmove', elementDrag);
                };
                
                handle.addEventListener('mousedown', dragMouseDown);
                handle.addEventListener('touchstart', dragMouseDown, { passive: false });
            }
            
            checkSession() {
                onAuthStateChanged(this.auth, async (user) => {
                    if (user) {
                        this.currentUser = user;
                        this.state.name = user.displayName || "Creator Of All Things";
                        await this.checkAdminStatus(user);
                        this.startGame();
                    } else {
                        this.showAuthScreen();
                    }
                });
            }
            
            async checkAdminStatus(user) {
                if (user.uid === this.ADMIN_UID) {
                    const panel = document.getElementById('admin-panel');
                    if (panel) {
                        panel.classList.remove('hidden');
                    }
                }
            }
            
            showAuthScreen() {
                const loadingScreen = document.getElementById('loading-screen');
                const authContainer = document.getElementById('auth-container');
                
                if (loadingScreen) loadingScreen.style.display = 'none';
                if (authContainer) {
                    authContainer.style.display = 'flex';
                    // Focus on email input
                    const emailInput = document.getElementById('login-email');
                    if (emailInput) emailInput.focus();
                }
            }
            
            async handleLogin() {
                const email = document.getElementById('login-email')?.value;
                const pass = document.getElementById('login-pass')?.value;
                const btn = document.getElementById('login-btn');
                
                if (!email || !pass) {
                    alert("Please enter both email and password");
                    return;
                }
                
                try {
                    btn.disabled = true;
                    btn.innerText = "OPENING GATES...";
                    await signInWithEmailAndPassword(this.auth, email, pass);
                } catch (error) {
                    alert(error.message);
                    btn.disabled = false;
                    btn.innerText = "ENTER THE DAO";
                }
            }
            
            async handleRegister() {
                const name = document.getElementById('reg-name')?.value;
                const email = document.getElementById('reg-email')?.value;
                const pass = document.getElementById('reg-pass')?.value;
                
                if (!name || !email || !pass) {
                    alert("Please fill in all fields");
                    return;
                }
                
                if (pass.length < 6) {
                    alert("Password must be at least 6 characters");
                    return;
                }
                
                try {
                    const res = await createUserWithEmailAndPassword(this.auth, email, pass);
                    await updateProfile(res.user, { displayName: name });
                    location.reload();
                } catch (error) {
                    alert(error.message);
                }
            }
            
            async handleForgot() {
                const email = document.getElementById('forgot-email')?.value;
                
                if (!email) {
                    alert("Please enter your email");
                    return;
                }
                
                try {
                    await sendPasswordResetEmail(this.auth, email);
                    alert("Divine link sent to email.");
                    this.switchAuth('login');
                } catch (error) {
                    alert(error.message);
                }
            }
            
            async signOut() {
                if (confirm("Are you sure you want to abandon your mortal shell?")) {
                    try {
                        await signOut(this.auth);
                        location.reload();
                    } catch (error) {
                        alert("Failed to sign out: " + error.message);
                    }
                }
            }
            
            switchAuth(view) {
                if (!['login', 'register', 'forgot'].includes(view)) return;
                
                // Hide all forms
                document.querySelectorAll('[id$="-form"]').forEach(form => {
                    form.classList.add('hidden');
                });
                
                // Show requested form
                const targetForm = document.getElementById(`${view}-form`);
                if (targetForm) {
                    targetForm.classList.remove('hidden');
                }
            }
            
            startGame() {
                // Hide loading and auth screens
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('auth-container').style.display = 'none';
                
                // Show game UI
                const gameUI = document.getElementById('game-ui');
                gameUI.style.opacity = '1';
                
                // Load saved state
                this.loadState();
                
                // Initialize game systems
                this.setupNetwork();
                this.listenToLeaderboard();
                this.listenToMap();
                
                // Show technique selection if needed
                if (!this.state.techniqueChosen) {
                    document.getElementById('technique-screen').style.display = 'flex';
                }
                
                // Start game loop
                this.startGameLoop();
                
                // Start auto-save
                this.saveInterval = setInterval(() => this.save(), 30000); // Save every 30 seconds
                
                // Initial render
                this.render();
            }
            
            loadState() {
                const saved = localStorage.getItem(this.SAVE_KEY_PREFIX + this.currentUser.uid);
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        // Merge with default state to ensure all properties exist
                        this.state = { ...this.getDefaultState(), ...parsed };
                        
                        // Migration for old saves
                        if (!this.state.version) {
                            this.state.version = "1.0.0";
                        }
                    } catch (error) {
                        console.error("Failed to parse saved state:", error);
                    }
                }
                
                // Set random position if not set
                if (this.state.pos === -1) {
                    this.state.pos = Math.floor(Math.random() * 25);
                }
            }
            
            save() {
                try {
                    localStorage.setItem(
                        this.SAVE_KEY_PREFIX + this.currentUser.uid, 
                        JSON.stringify(this.state)
                    );
                } catch (error) {
                    console.error("Failed to save game state:", error);
                }
            }
            
            startGameLoop() {
                if (this.gameLoop) clearInterval(this.gameLoop);
                this.gameLoop = setInterval(() => this.tick(), 100);
            }
            
            tick() {
                if (this.state.isDead) return;
                
                const now = Date.now();
                const dt = Math.min((now - this.state.lastTick) / 1000, 1); // Cap dt to 1 second
                this.state.lastTick = now;
                
                // Update move cooldown
                if (this.state.moveCooldown > 0) {
                    this.state.moveCooldown -= dt;
                }
                
                // Calculate Qi gain rate
                const techRate = this.getTechniqueRate();
                const currentTile = this.mapData[this.state.pos];
                const mapBonus = (currentTile && currentTile.lord === this.state.name) ? currentTile.density : 1.0;
                const rate = (1 + this.state.upgrades.spirit) * 
                           Math.pow(1.5, this.state.realmIdx) * 
                           this.state.rootMult * 
                           techRate * 
                           mapBonus;
                
                // Add Qi
                const currentRealm = this.realms[this.state.realmIdx];
                if (currentRealm) {
                    this.state.qi = Math.min(currentRealm.req, this.state.qi + (rate * dt));
                }
                
                // Age progression (1 real minute = 1 game year)
                this.state.age += dt / 60;
                
                // Check for death
                if (this.state.age >= this.state.maxAge) {
                    this.die();
                }
                
                // Request render on next frame
                this.requestRender(rate);
            }
            
            getTechniqueRate() {
                switch (this.state.technique) {
                    case 'turtle': return 0.7;
                    case 'phoenix': return 2.0;
                    case 'dao':
                    default: return 1.0;
                }
            }
            
            requestRender(rate = 0) {
                if (this.renderFrameId) {
                    cancelAnimationFrame(this.renderFrameId);
                }
                
                this.renderFrameId = requestAnimationFrame(() => {
                    this.render(rate);
                    this.renderFrameId = null;
                });
            }
            
            setTechnique(type) {
                if (!['turtle', 'dao', 'phoenix'].includes(type)) return;
                
                this.state.technique = type;
                this.state.techniqueChosen = true;
                document.getElementById('technique-screen').style.display = 'none';
                this.save();
            }
            
            manualMeditate() {
                const techRate = this.getTechniqueRate();
                const currentTile = this.mapData[this.state.pos];
                const mapBonus = (currentTile && currentTile.lord === this.state.name) ? currentTile.density : 1.0;
                const power = (10 + (this.state.realmIdx * 50)) * this.state.rootMult * techRate * mapBonus;
                
                const currentRealm = this.realms[this.state.realmIdx];
                if (currentRealm) {
                    this.state.qi = Math.min(currentRealm.req, this.state.qi + power);
                }
                
                // Add visual feedback
                const meditateBtn = document.getElementById('meditate-btn');
                meditateBtn.classList.add('shimmer');
                setTimeout(() => {
                    meditateBtn.classList.remove('shimmer');
                }, 300);
                
                this.addLog(`<span class="text-purple-400">Manually cultivated +${Math.floor(power)} Qi</span>`);
                this.render();
            }
            
            async breakthrough() {
                const currentRealm = this.realms[this.state.realmIdx];
                if (!currentRealm) return;
                
                let successMod = this.state.technique === 'turtle' ? 1.5 : 
                               this.state.technique === 'phoenix' ? 0.8 : 1.0;
                
                if (Math.random() <= (currentRealm.chance * successMod)) {
                    // Success
                    this.state.realmIdx++;
                    this.state.qi = 0;
                    this.state.maxAge += 50;
                    
                    this.addLog(`<span class="text-green-400">üåü Advanced to ${this.realms[this.state.realmIdx]?.name || 'Unknown'}!</span>`);
                    
                    // Update leaderboard
                    try {
                        await setDoc(doc(this.db, "highscores", this.currentUser.uid), {
                            player: this.state.name,
                            realm: this.realms[this.state.realmIdx]?.name || 'Unknown',
                            level: this.state.realmIdx,
                            updatedAt: serverTimestamp()
                        });
                    } catch (error) {
                        console.error("Failed to update leaderboard:", error);
                    }
                } else {
                    // Failure
                    this.state.qi *= 0.5;
                    this.addLog(`<span class="text-red-500">‚ö°Ô∏è Breakthrough Failed! Qi reduced by half.</span>`);
                }
                
                this.save();
            }
            
            async occupyTile(id) {
                if (this.state.moveCooldown > 0) return;
                if (id < 0 || id >= this.mapData.length) return;
                
                const target = this.mapData[id];
                const myRow = Math.floor(this.state.pos / 5);
                const myCol = this.state.pos % 5;
                const tRow = Math.floor(id / 5);
                const tCol = id % 5;
                
                // Check if tile is adjacent
                if (Math.abs(myRow - tRow) > 1 || Math.abs(myCol - tCol) > 1) {
                    this.addLog(`<span class="text-yellow-500">Tile is too far away</span>`);
                    return;
                }
                
                // Check if already occupying
                if (target.lord === this.state.name) {
                    this.addLog(`<span class="text-blue-400">Already occupying this tile</span>`);
                    return;
                }
                
                // Battle logic if tile is occupied
                if (target.lord) {
                    const win = this.state.realmIdx > target.level || 
                              (this.state.realmIdx === target.level && this.state.qi > (target.lordQi || 0));
                    
                    if (!win) {
                        this.state.qi *= 0.7;
                        this.state.moveCooldown = 5;
                        this.addLog(`<span class="text-red-500">Lost battle against ${target.lord}! Qi reduced.</span>`);
                        return;
                    } else {
                        this.addLog(`<span class="text-green-400">Defeated ${target.lord} and claimed their tile!</span>`);
                    }
                }
                
                // Occupy tile
                try {
                    await setDoc(doc(this.db, "map", `tile_${id}`), {
                        lord: this.state.name,
                        level: this.state.realmIdx,
                        lordQi: this.state.qi,
                        density: target.density,
                        at: serverTimestamp()
                    });
                    
                    this.state.pos = id;
                    this.save();
                } catch (error) {
                    console.error("Failed to occupy tile:", error);
                    this.addLog(`<span class="text-red-500">Failed to occupy tile</span>`);
                }
            }
            
            listenToMap() {
                const mapQuery = query(collection(this.db, "map"));
                
                onSnapshot(mapQuery, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        const id = parseInt(change.doc.id.split('_')[1]);
                        if (!isNaN(id) && id >= 0 && id < this.mapData.length) {
                            this.mapData[id] = { ...this.mapData[id], ...change.doc.data() };
                        }
                    });
                    this.renderMap();
                }, (error) => {
                    console.error("Map listener error:", error);
                });
            }
            
            renderMap() {
                const container = document.getElementById('map-container');
                if (!container) return;
                
                // Use DocumentFragment for better performance
                const fragment = document.createDocumentFragment();
                const myRow = Math.floor(this.state.pos / 5);
                const myCol = this.state.pos % 5;
                
                this.mapData.forEach((tile) => {
                    const tRow = Math.floor(tile.id / 5);
                    const tCol = tile.id % 5;
                    const isVisible = Math.abs(myRow - tRow) <= 1 && Math.abs(myCol - tCol) <= 1;
                    
                    const div = document.createElement('div');
                    div.className = `tile ${tile.id === this.state.pos ? 'tile-active' : ''} ${!isVisible ? 'fog' : (tile.lord ? 'tile-occupied' : 'bg-black/40')}`;
                    
                    if (isVisible) {
                        div.innerHTML = `
                            <span class="text-gray-500 font-mono">${tile.density.toFixed(1)}x</span>
                            <span class="truncate w-full text-center font-bold" style="color:${tile.lord ? '#a855f7' : '#444'}">
                                ${tile.lord || 'Empty'}
                            </span>
                        `;
                        div.addEventListener('click', () => this.occupyTile(tile.id));
                    } else {
                        div.innerHTML = `???`;
                        div.style.cursor = 'not-allowed';
                    }
                    
                    fragment.appendChild(div);
                });
                
                container.innerHTML = '';
                container.appendChild(fragment);
            }
            
            async adminResetMap() {
                if (!confirm("Are you sure you want to wipe all lords from the world map?")) {
                    return;
                }
                
                try {
                    const promises = this.mapData.map((_, i) => {
                        return setDoc(doc(this.db, "map", `tile_${i}`), {
                            lord: null,
                            level: 0,
                            lordQi: 0,
                            density: 1 + (i % 5 * 0.5),
                            at: serverTimestamp()
                        });
                    });
                    
                    await Promise.all(promises);
                    this.addLog(`<span class="text-red-500">[ADMIN] World map has been reset</span>`);
                } catch (error) {
                    console.error("Failed to reset map:", error);
                    alert("Failed to reset map: " + error.message);
                }
            }
            
            adminAddKarma() {
                this.state.karma += 10000;
                this.addLog(`<span class="text-yellow-500">[ADMIN] Received 10,000 Karma</span>`);
                this.save();
                this.render();
            }
            
            die() {
                this.state.isDead = true;
                const karmaGain = this.state.realmIdx * 20;
                this.state.karma += karmaGain;
                
                document.getElementById('karma-gain').innerText = karmaGain;
                document.getElementById('reincarnation-screen').style.display = 'flex';
                
                this.addLog(`<span class="text-red-500">üíÄ Life exhausted. Gained ${karmaGain} Karma.</span>`);
            }
            
            reincarnate(mult, cost) {
                if (this.state.karma < cost) {
                    alert("Insufficient Karma for this reincarnation");
                    return;
                }
                
                this.state.karma -= cost;
                this.state.rootMult = mult;
                this.state.age = 18;
                this.state.maxAge = 100;
                this.state.realmIdx = 0;
                this.state.qi = 0;
                this.state.techniqueChosen = false;
                this.state.isDead = false;
                
                document.getElementById('reincarnation-screen').style.display = 'none';
                document.getElementById('technique-screen').style.display = 'flex';
                
                this.addLog(`<span class="text-green-400">üåÄ Reincarnated with ${mult}x cultivation speed</span>`);
                this.save();
            }
            
            render(rate = 0) {
                const currentRealm = this.realms[this.state.realmIdx];
                if (!currentRealm) return;
                
                // Update DOM elements
                this.updateElement('p-name', this.state.name);
                this.updateElement('p-realm', currentRealm.name);
                this.updateElement('qi-val', Math.floor(this.state.qi).toLocaleString());
                this.updateElement('age', Math.floor(this.state.age));
                this.updateElement('maxAge', Math.floor(this.state.maxAge));
                this.updateElement('karma', Math.floor(this.state.karma));
                this.updateElement('rate-val', Math.floor(rate).toLocaleString());
                
                // Update Qi bar
                const qiBar = document.getElementById('qi-bar');
                if (qiBar) {
                    const percentage = Math.min(100, (this.state.qi / currentRealm.req * 100));
                    qiBar.style.width = percentage + "%";
                }
                
                // Update realm color
                document.documentElement.style.setProperty('--realm-color', currentRealm.color);
                
                // Show/hide breakthrough button
                const breakBtn = document.getElementById('break-btn');
                if (breakBtn) {
                    breakBtn.style.display = (this.state.qi >= currentRealm.req) ? 'block' : 'none';
                }
            }
            
            updateElement(id, text) {
                const element = document.getElementById(id);
                if (element && element.textContent !== String(text)) {
                    element.textContent = text;
                }
            }
            
            addLog(message) {
                const logContainer = document.getElementById('log');
                if (!logContainer) return;
                
                const entry = document.createElement('div');
                entry.className = "border-l-2 border-purple-500 pl-2 mb-1 py-1";
                entry.innerHTML = `${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}: ${message}`;
                
                logContainer.prepend(entry);
                
                // Limit log entries
                const entries = logContainer.children;
                if (entries.length > 50) {
                    logContainer.removeChild(entries[entries.length - 1]);
                }
                
                // Auto-scroll to top
                logContainer.scrollTop = 0;
            }
            
            listenToLeaderboard() {
                const leaderboardQuery = query(
                    collection(this.db, "highscores"),
                    orderBy("level", "desc"),
                    limit(20)
                );
                
                onSnapshot(leaderboardQuery, (snapshot) => {
                    const list = document.getElementById('leaderboard-list');
                    if (!list) return;
                    
                    list.innerHTML = '';
                    
                    snapshot.forEach((doc, index) => {
                        const data = doc.data();
                        const li = document.createElement('li');
                        li.className = "p-3 bg-white/5 rounded-xl border-l-4 border-purple-500 text-xs hover:bg-white/10 transition-colors";
                        li.innerHTML = `
                            <div class="flex justify-between items-center">
                                <span class="font-bold text-purple-300">#${index + 1}</span>
                                <span class="text-[10px] text-gray-500">${data.level}</span>
                            </div>
                            <b class="text-white">${data.player}</b>
                            <div class="text-yellow-500 text-[11px] mt-1 truncate">${data.realm}</div>
                        `;
                        list.appendChild(li);
                    });
                }, (error) => {
                    console.error("Leaderboard listener error:", error);
                });
            }
            
            setupNetwork() {
                // Chat listener
                const chatQuery = query(
                    collection(this.db, "messages"),
                    orderBy("createdAt", "desc"),
                    limit(20)
                );
                
                onSnapshot(chatQuery, (snapshot) => {
                    const chatContainer = document.getElementById('chat');
                    if (!chatContainer) return;
                    
                    // Store messages in reverse order for display
                    const messages = [];
                    snapshot.forEach(doc => {
                        messages.unshift(doc.data());
                    });
                    
                    // Update chat display
                    chatContainer.innerHTML = messages.map(data => `
                        <div class="bg-white/5 p-2 rounded-lg hover:bg-white/10 transition-colors">
                            <b class="text-purple-400">${data.user}</b>: ${data.text}
                            <div class="text-[10px] text-gray-500 text-right mt-1">
                                ${data.createdAt?.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) || 'Just now'}
                            </div>
                        </div>
                    `).join('');
                    
                    // Auto-scroll to bottom
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                });
            }
            
            async sendChatMessage() {
                const input = document.getElementById('chat-input');
                if (!input || !input.value.trim()) return;
                
                const message = input.value.trim().slice(0, 200); // Limit message length
                
                try {
                    await addDoc(collection(this.db, "messages"), {
                        user: this.state.name,
                        text: message,
                        createdAt: serverTimestamp(),
                        uid: this.currentUser.uid
                    });
                    
                    input.value = "";
                    input.focus();
                } catch (error) {
                    console.error("Failed to send message:", error);
                    alert("Failed to send message: " + error.message);
                }
            }
        }
        
        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new Game();
            window.game.init();
        });
    </script>
</body>
</html>
